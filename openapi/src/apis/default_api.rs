/*
 * The Enlighten Systems API
 *
 * The Enlighten Systems API is a JSON-based API that provides access to performance data for a PV system. By using the Enlighten Systems API, you agree to the Enphase Energy API License Agreement.  Please note that the Enlighten Systems API does not provide performance data at a panel or microinverter level.
 *
 * The version of the OpenAPI document: 2.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `consumption_lifetime`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConsumptionLifetimeError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `consumption_stats`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConsumptionStatsError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `energy_lifetime`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnergyLifetimeError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `envoys`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnvoysError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `inventory`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InventoryError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `inverters_summary_by_envoy_or_site`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InvertersSummaryByEnvoyOrSiteError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `monthly_production`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MonthlyProductionError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `production_meter_readings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductionMeterReadingsError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `rgm_stats`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RgmStatsError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `search_system_id`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchSystemIdError {
    Status401(crate::models::ClientError),
    Status404(crate::models::NotFoundError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `stats`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StatsError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `summary`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SummaryError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `systems`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SystemsError {
    Status401(crate::models::ClientError),
    Status409(crate::models::ConflictError),
    Status422(crate::models::UnprocessableEntityError),
    Status500(crate::models::ServerError),
    Status503(crate::models::ServerError),
    UnknownValue(serde_json::Value),
}


/// Returns a time series of energy consumption as measured by the consumption meter installed on the specified system. All measurements are in Watt-hours. If the system does not have a meter, returns `204` - No Content. If you don't have permission to view consumption data, the response code is `401`.  The time series includes one entry for each day from the `start_date` to the `end_date`. There are no gaps in the time series. If the response includes trailing zeroes, such as [909, 4970, 0, 0, 0], then no data has been reported for the last days in the series. You can check the system's status in the `meta` attribute of the response to determine when the system last reported and whether it has communication or metering problems.
pub async fn consumption_lifetime(configuration: &configuration::Configuration, user_id: &str, system_id: i32, start_date: Option<String>, end_date: Option<String>) -> Result<crate::models::ConsumptionLifetimeResponse, Error<ConsumptionLifetimeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/consumption_lifetime", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConsumptionLifetimeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns consumption as measured by the consumption meter installed on the specified system. If the total duration requested is more than one month, returns one month of intervals. Intervals are 15 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 15-minute marks are rounded down. For example, a request for 08:01, 08:08, 08:11, or 08:14 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 15 minutes after the requested start date.  If the system doesn't have any consumption meters installed, the response includes an empty intervals array.  If you don't have permission to view consumption data, the response code is `401`.  Under some conditions, data for a given period may be temporarily unavailable.
pub async fn consumption_stats(configuration: &configuration::Configuration, user_id: &str, system_id: i32, start_at: Option<i64>, end_at: Option<i64>) -> Result<crate::models::ConsumptionStatsResponse, Error<ConsumptionStatsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/consumption_stats", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = start_at {
        local_var_req_builder = local_var_req_builder.query(&[("start_at", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_at {
        local_var_req_builder = local_var_req_builder.query(&[("end_at", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ConsumptionStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a time series of energy produced on the system over its lifetime. All measurements are in Watt-hours.  The time series includes one entry for each day from the `start_date` to the `end_date`. There are no gaps in the time series. If the response includes trailing zeroes, such as `[909, 4970, 0, 0, 0]`, then no energy has been reported for the last days in the series. You can check the system's status in the `meta` attribute of the response to determine when the system last reported and whether it has communication or production problems.  If the system has a meter, the time series includes data as measured by the microinverters until the first full day after the meter has been installed, when it switches to using the data as measured by the meter. This is called the \"merged time series\". In addition, the response includes the attribute `meter_start_date`, to indicate where in the time series the meter measurements begin to be used. You can retrieve the complete time series from the meter and from the microinverters by adding the parameter `production=all` to the request.
pub async fn energy_lifetime(configuration: &configuration::Configuration, user_id: &str, system_id: i32, start_date: Option<String>, end_date: Option<String>, production: Option<&str>) -> Result<crate::models::EnergyLifetimeResponse, Error<EnergyLifetimeError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/energy_lifetime", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = production {
        local_var_req_builder = local_var_req_builder.query(&[("production", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EnergyLifetimeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a listing of all active Envoys currently deployed on the system.
pub async fn envoys(configuration: &configuration::Configuration, user_id: &str, system_id: i32) -> Result<crate::models::EnvoysResponse, Error<EnvoysError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/envoys", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EnvoysError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a listing of active devices on the given system. A device is considered active if it has not been retired in Enlighten. \"Active\" does not imply that the device is currently reporting, producing, or measuring energy.
pub async fn inventory(configuration: &configuration::Configuration, user_id: &str, system_id: i32) -> Result<crate::models::InventoryResponse, Error<InventoryError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/inventory", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<InventoryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the summary along with the energy produced on the system over its lifetime.
pub async fn inverters_summary_by_envoy_or_site(configuration: &configuration::Configuration, user_id: &str, site_id: i32) -> Result<Vec<crate::models::InvertersSummaryByEnvoyOrSiteResponse>, Error<InvertersSummaryByEnvoyOrSiteError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/inverters_summary_by_envoy_or_site", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("site_id", &site_id.to_string())]);
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<InvertersSummaryByEnvoyOrSiteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint is deprecated and will be removed in a future release. Use `production_meter_readings` or `energy_lifetime` instead.  Returns the energy production of the system for the month starting on the given date. The start date must be at least one month ago. If a meter or meters are installed on the system, measurements come from the meter; otherwise, measurements come from the microinverters.  This endpoint can return a response of Data Temporarily Unavailable.
pub async fn monthly_production(configuration: &configuration::Configuration, user_id: &str, system_id: i32, start_date: String) -> Result<crate::models::MonthlyProductionResponse, Error<MonthlyProductionError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/monthly_production", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("start_date", &start_date.to_string())]);
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MonthlyProductionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the last known \"odometer\" reading of each revenue-grade production meter on the system as of the requested time.  This endpoint includes entries for every production meter on the requested system, regardless of whether the meter is currently in service or retired. `read_at` is the time at which the reading was taken, and is always less than or equal to the requested `end_at`. Commonly, the reading will be within 30 minutes of the requested `end_at`; however, larger deltas can occur and do not necessarily mean there is a problem with the meter or the system it is on. Systems that are configured to report infrequently can show large deltas on all meters, especially when `end_at` is close to the current time. Meters that have been retired from a system will show an `end_at` that doesn't change, and that eventually is far away from the current time.
pub async fn production_meter_readings(configuration: &configuration::Configuration, user_id: &str, system_id: i32, end_at: Option<i64>) -> Result<crate::models::ProductionMeterReadingsResponse, Error<ProductionMeterReadingsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/production_meter_readings", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = end_at {
        local_var_req_builder = local_var_req_builder.query(&[("end_at", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ProductionMeterReadingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns performance statistics as measured by the revenue-grade meters installed on the specified system. If the total duration requested is more than one month, returns one month of intervals. Intervals are 15 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 15-minute marks are rounded down. For example, a request for 08:01, 08:08, 08:11, or 08:14 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 15 minutes after the requested start date.  If the system doesn't have any revenue-grade meters installed, the response includes an empty intervals array.  Under some conditions, data for a given period may be temporarily unavailable.
pub async fn rgm_stats(configuration: &configuration::Configuration, user_id: &str, system_id: i32, start_at: Option<i64>, end_at: Option<i64>) -> Result<crate::models::RgmStatsResponse, Error<RgmStatsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/rgm_stats", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = start_at {
        local_var_req_builder = local_var_req_builder.query(&[("start_at", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_at {
        local_var_req_builder = local_var_req_builder.query(&[("end_at", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RgmStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get system ID by envoy serial number.
pub async fn search_system_id(configuration: &configuration::Configuration, user_id: &str, serial_num: &str) -> Result<crate::models::SearchSystemIdResponse, Error<SearchSystemIdError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/search_system_id", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("serial_num", &serial_num.to_string())]);
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SearchSystemIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns performance statistics for the specified system as reported by microinverters installed on the system. If the total duration requested is more than one day, returns one day of intervals. Intervals are 5 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 5-minute marks are rounded down. For example, a request for 08:01, 08:02, 08:03, or 08:04 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 5 minutes after the requested start date.  The response includes intervals that have been reported for the requested period. Gaps in reporting are not filled with 0-value intervals. The dark hours on a system are an example of such a gap, because the microinverters do not produce at night.  Sometimes a request cannot be processed because the requested dates are invalid for the the system in question. Examples include asking for stats starting at a time that is later than the system's last reported interval, or asking for stats before a system has started production. In cases such as these, the response code is `422` and the response body includes an error reason as well as the parameters used to process the request.  If the system doesn't have any microinverters installed, the response includes an empty intervals array. Under some conditions, data for a given period may be temporarily unavailable.
pub async fn stats(configuration: &configuration::Configuration, user_id: &str, system_id: i32, start_at: Option<i64>, end_at: Option<i64>) -> Result<crate::models::StatsResponse, Error<StatsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/stats", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = start_at {
        local_var_req_builder = local_var_req_builder.query(&[("start_at", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_at {
        local_var_req_builder = local_var_req_builder.query(&[("end_at", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns summary information for the specified system.
pub async fn summary(configuration: &configuration::Configuration, user_id: &str, system_id: i32, summary_date: Option<String>) -> Result<crate::models::SummaryResponse, Error<SummaryError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems/{system_id}/summary", configuration.base_path, system_id=system_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = summary_date {
        local_var_req_builder = local_var_req_builder.query(&[("summary_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SummaryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of systems for which the user can make API requests. There is a limit to the number of systems that can be returned at one time. If the first request does not return a full list, use the `next` attribute in the response body to request the next page of systems. By default, systems are returned in batches of 100. The maximum page size is 1000.
pub async fn systems(configuration: &configuration::Configuration, user_id: &str, next: Option<&str>, limit: Option<i32>, system_id: Option<i32>, system_id2: Option<Vec<i32>>, system_name: Option<&str>, system_name2: Option<Vec<String>>, status: Option<crate::models::Status>, status2: Option<Vec<crate::models::Status>>, reference: Option<&str>, reference2: Option<Vec<String>>, installer: Option<&str>, installer2: Option<Vec<String>>, connection_type: Option<crate::models::ConnectionType>, connection_type2: Option<Vec<crate::models::ConnectionType>>) -> Result<crate::models::SystemsResponse, Error<SystemsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/systems", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = next {
        local_var_req_builder = local_var_req_builder.query(&[("next", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = system_id {
        local_var_req_builder = local_var_req_builder.query(&[("system_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = system_id2 {
        local_var_req_builder = local_var_req_builder.query(&[("system_id[]", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = system_name {
        local_var_req_builder = local_var_req_builder.query(&[("system_name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = system_name2 {
        local_var_req_builder = local_var_req_builder.query(&[("system_name[]", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = status {
        local_var_req_builder = local_var_req_builder.query(&[("status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = status2 {
        local_var_req_builder = local_var_req_builder.query(&[("status[]", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = reference {
        local_var_req_builder = local_var_req_builder.query(&[("reference", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = reference2 {
        local_var_req_builder = local_var_req_builder.query(&[("reference[]", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = installer {
        local_var_req_builder = local_var_req_builder.query(&[("installer", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = installer2 {
        local_var_req_builder = local_var_req_builder.query(&[("installer[]", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = connection_type {
        local_var_req_builder = local_var_req_builder.query(&[("connection_type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = connection_type2 {
        local_var_req_builder = local_var_req_builder.query(&[("connection_type[]", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.query(&[("key", local_var_value)]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SystemsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

